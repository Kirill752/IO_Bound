# Сервис для работы с I/O BOUND задач

## Table of Contents

- [О сервисе](#about)
- [Начало работы](#getting_started)
- [Использование](#usage)
- [Что еще можно улучшить?](#upsclae)

## О сервисе <a name = "about"></a>

Данный сервис реализует функционал, с помощью которого можно создавать I/O BOUND  задачи и получать результаты их работы.
Для хранения задач используется Redis, который реализует алгоритм LRU кеширования. То есть при достижении лимита по памяти, данные о наименее часто используемой задачи удаляются, это позволяет оптимизировать хранение результатов работы задач. Для более быстрого выполнения множества задач используется паттерн конкурентного программирования Worker Pool. Благодаря этому различные задачи выполняются конкурентно в разных горутинах, что значительно ускоряет работу при большом количестве задач. В main.go приведен пример создания обработчика, который имитирует долгую работу (например, обработка PDF).

## Начало работы <a name = "getting_started"></a>

Чтобы запустить сервис убедитесь, что у вас установлен компиятор GO и Docker.

## Использование <a name = "usage"></a>

Для начала работы необходимо развернуть образ Redis. Для этого необходимо выполнить команды из корневого каталога.
```
cd DB
docker-compose up -d
```
После этого можно запустить сервис при помощи команды
```
go run main.go
```
После этого можно отправлять запросы о создании новых задач. Вот пример:
```
curl -X POST -H "Content-Type: application/json" -d '{"type":"pdfHandler","text":"test content"}' http://localhost:8080/task
```
Этот код запустит обработчик, который приведен в файле main.go
Созданную задачу можно посмотреть в браузере по адресу
```
http://localhost:8080
```
Или отправив GET запрос при помощи curl.

## Что еще можно улучшить? <a name = "upscale"></a>

- Нужно всю конфигурацию перенести из кода в config файл.
- Улучшить логирование. Использовать slog.
- Добавить обработчиков, которые выполняют работу, а не имитируют её.

Но на это у меня не хватает времени...